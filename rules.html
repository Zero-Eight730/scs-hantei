<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ルール設定 - モギモギ判定</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>
    <script src="supabase-client.js"></script>
</head>
<body>
    <div id="main-app" class="container" style="display:none;">
        <nav>
            <a href="input.html">成績入力</a>
            <a href="view.html">成績参照</a>
            <a href="judge.html">判定実行</a>
            <a href="majors.html">志望学類登録</a>
            <strong>学類登録</strong>
            <a href="admin-settings.html" class="admin-only">公開設定</a>
            <a href="account.html">アカウント管理</a>
        </nav>
        <div class="user-status">
            <span id="user-display"></span>
            <button id="logout-btn" class="btn-danger" style="padding: 5px 10px; font-size: 14px;">ログアウト</button>
        </div>
        <div class="panel">
            <h2>学類計算ルール（全ユーザー共通）</h2>
            <p style="text-align:center;">管理者権限を持つアカウントで、全ユーザーが利用できる共通ルールを作成・編集します。</p>
            <div id="custom-majors-container"></div>
            <button id="add-major-btn" class="btn-action" style="margin-top: 20px;">新しい学類ルールを追加</button>
            <button id="save-order-btn" class="btn-main" style="width: 100%; margin-top: 10px; display: none;">現在の並び順を保存</button>
        </div>
    </div>

    <datalist id="master-subjects-list"></datalist>

    <script>
        let currentUser = null;
        let masterSubjects = [];
        let majorRules = [];

        const userDisplay = document.getElementById('user-display');
        const logoutBtn = document.getElementById('logout-btn');
        const customMajorsContainer = document.getElementById('custom-majors-container');
        const addMajorBtn = document.getElementById('add-major-btn');
        const saveOrderBtn = document.getElementById('save-order-btn');
        const masterSubjectsDatalist = document.getElementById('master-subjects-list');

        async function setupUserInterface() {
            const { data: { session }, error } = await supabaseClient.auth.getSession();
            if (error || !session) { window.location.href = 'index.html'; return null; }
            const user = session.user;
            const { data: profile } = await supabaseClient.from('profiles').select('role').eq('id', user.id).single();
            const isAdmin = profile && profile.role === 'admin';
            if (!isAdmin) { alert('アクセス権限がありません。'); window.location.href = 'input.html'; return null; }
            document.getElementById('main-app').style.display = 'block';
            userDisplay.textContent = `${user.email} でログイン中 [管理者]`;
            document.querySelectorAll('.admin-only').forEach(link => { if (isAdmin) { link.style.display = 'inline-block'; } });
            return { user, isAdmin };
        }

        async function initializeApp() {
            try {
                const response = await fetch('kdb_2025.csv');
                const csvText = await response.text();
                Papa.parse(csvText, { header: true, skipEmptyLines: true, complete: (results) => {
                    const uniqueSubjects = new Map();
                    results.data.forEach(row => {
                        const name = row['科目名'] ? row['科目名'].trim() : '';
                        const credits = parseFloat(row['単位数']);
                        if(name && !isNaN(credits)) {
                            const key = `${name}|${credits}`;
                            if (!uniqueSubjects.has(key)) { uniqueSubjects.set(key, { name, credits }); }
                        }
                    });
                    masterSubjects = Array.from(uniqueSubjects.values()).sort((a, b) => a.name.localeCompare(b.name, 'ja'));
                    masterSubjectsDatalist.innerHTML = masterSubjects.map(subject => `<option value="${subject.name}"></option>`).join('');
                }});
            } catch (error) { alert('科目マスターリストの読み込みに失敗しました。'); }
            await loadMajorRules();
        }

        async function loadMajorRules() {
            try {
                const { data, error } = await supabaseClient.from('major_rules').select('id, user_id, name, allowed_roles, rule_data, sort_order').order('sort_order');
                if (error) throw error;
                majorRules = data.map(r => ({ id: r.id, userId: r.user_id, name: r.name, allowed_roles: r.allowed_roles, ...r.rule_data, sort_order: r.sort_order }));
                renderAllRules();
            } catch (e) { console.error('共通ルールの読み込み失敗:', e); }
        }

        function renderAllRules() {
            const openDetails = new Set(Array.from(document.querySelectorAll('.rule-editor[open]')).map(el => el.dataset.majorId));
            customMajorsContainer.innerHTML = '';
            majorRules.forEach((rule, index) => {
                const ruleEl = createRuleElement(rule, index);
                if (openDetails.has(rule.id || `new-${index}`)) { ruleEl.open = true; }
                customMajorsContainer.appendChild(ruleEl);
            });
        }

        function createRuleElement(rule, majorIndex) {
            const majorDetails = document.createElement('details');
            majorDetails.className = 'rule-editor';
            majorDetails.dataset.majorId = rule.id || `new-${majorIndex}`;
            majorDetails.draggable = true;
            const editorHTML = createEditorHTML(rule);
            majorDetails.innerHTML = `
                <summary>
                    <span class="drag-handle">⠿</span>
                    <span class="summary-title">${rule.name || '新規学類ルール'}</span>
                </summary>
                <div class="rule-editor-content">
                    <div class="rule-editor-header">
                        <input type="text" class="major-name" value="${rule.name || ''}" placeholder="学類名">
                        <button class="btn-action duplicate-major-btn">複製</button>
                        <button class="btn-danger remove-major-btn">削除</button>
                    </div>
                    <div class="editor-content-wrapper">${editorHTML}</div>
                </div>
            `;
            return majorDetails;
        }

        function createEditorHTML(rule) {
            let groupsHTML = (rule.groups || []).map(createGroupHTML).join('');
            let combinedLimitsHTML = (rule.combinedLimits || []).map(limit => createCombinedLimitHTML(limit, rule.groups || [])).join('');
            const roles = { arts: '文系', sci_1: '理系Ⅰ', sci_2: '理系Ⅱ', sci_3: '理系Ⅲ' };
            let rolesHTML = '<div class="roles-container"><h5>対象ロール</h5>';
            for (const [roleKey, roleName] of Object.entries(roles)) {
                const isChecked = (rule.allowed_roles || []).includes(roleKey);
                rolesHTML += `<label><input type="checkbox" class="role-checkbox" value="${roleKey}" ${isChecked ? 'checked' : ''}> ${roleName}</label>`;
            }
            rolesHTML += '</div>';
             return `
                ${rolesHTML}
                <div class="rule-settings-grid">
                    <input type="number" class="total-cap" value="${rule.totalCap || '24'}" placeholder="総単位数上限">
                    <input type="number" class="other-weight" value="${rule.otherWeight || '1.0'}" step="0.1" placeholder="その他重み">
                    <input type="number" class="other-cap" value="${rule.otherCap || '0'}" placeholder="その他単位数上限 (0=無制限)">
                </div>
                <h5>判定基準 (該当ロール用)</h5>
                <div class="rule-settings-grid">
                     <input type="number" class="pass-threshold-app" value="${rule.thresholds?.applicable?.pass || ''}" placeholder="合格最低点">
                    <input type="number" class="median-threshold-app" value="${rule.thresholds?.applicable?.median || ''}" placeholder="中央値">
                </div>
                <h5>判定基準 (非該当ロール用)</h5>
                <div class="rule-settings-grid">
                     <input type="number" class="pass-threshold-nonapp" value="${rule.thresholds?.non_applicable?.pass || ''}" placeholder="合格最低点">
                    <input type="number" class="median-threshold-nonapp" value="${rule.thresholds?.non_applicable?.median || ''}" placeholder="中央値">
                </div>
                 <h5>満点</h5>
                <div class="rule-settings-grid">
                    <input type="number" class="max-possible-score" value="${rule.maxPossibleScore || ''}" placeholder="満点">
                </div>
                <hr>
                <h3>科目グループ (上にあるほど優先)</h3>
                <p style="font-size:0.9em; color:#666;">科目リストを空にすると、そのグループは「その他」として扱われ、どのグループにも属さない残りの科目がすべて対象になります。</p>
                <div class="groups-container">${groupsHTML}</div>
                <button class="btn-add add-group-btn">科目グループを追加</button>
                <hr>
                <h3>科目グループ合計の上限設定</h3>
                <div class="combined-limits-container">${combinedLimitsHTML}</div>
                <button class="btn-add add-combined-limit-btn">新しい合計上限を追加</button>
                <hr>
                <button class="btn-main save-one-rule-btn" style="width:100%; margin-top:10px;">このルールを保存</button>
            `;
        }
        
        function createGroupHTML(group) {
            const subjectsHTML = (group.subjects || []).map(subjectName => `<div class="subject-tag">${subjectName}<span class="remove-subject-tag">&times;</span></div>`).join('');
            return `
                <div class="group-box">
                    <div class="rule-settings-grid">
                        <input type="text" class="group-name" value="${group.name || ''}" placeholder="グループ名 (例: 重点科目, その他)">
                        <input type="number" class="group-weight" value="${group.weight || '1.0'}" step="0.1" placeholder="重み">
                        <input type="number" class="group-cap" value="${group.cap || '0'}" placeholder="単位数上限 (0=無制限)">
                        <button class="btn-danger remove-group-btn">削除</button>
                    </div>
                    <div class="subjects-container">${subjectsHTML}</div>
                    <div class="subject-add-area">
                        <input type="text" class="new-subject-name" placeholder="科目名を入力 or 選択..." list="master-subjects-list">
                        <button type="button" class="btn-add add-subject-to-group-btn">追加</button>
                    </div>
                </div>
            `;
        }

        function createCombinedLimitHTML(limit, groups) {
            let checkboxesHTML = '';
            (groups || []).forEach(group => {
                if (group.name) {
                    const isChecked = (limit.groupNames || []).includes(group.name);
                    checkboxesHTML += `<label><input type="checkbox" class="combined-group-checkbox" value="${group.name}" ${isChecked ? 'checked' : ''}> ${group.name}</label>`;
                }
            });
            return `
                <div class="group-box combined-limit-box">
                     <div class="rule-settings-grid">
                        <input type="text" class="combined-limit-name" value="${limit.name || ''}" placeholder="合計上限名 (例: A+B上限)">
                        <input type="number" class="combined-limit-cap" value="${limit.cap || ''}" placeholder="合計単位数上限">
                        <button class="btn-danger remove-combined-limit-btn">削除</button>
                     </div>
                     <h5>対象グループ</h5>
                     <div class="combined-groups-checkboxes">${checkboxesHTML}</div>
                </div>
            `;
        }

        document.addEventListener('DOMContentLoaded', async () => {
            const sessionInfo = await setupUserInterface();
            if(sessionInfo){ currentUser = sessionInfo.user; await initializeApp(); }
        });
        
        logoutBtn.addEventListener('click', async () => { await supabaseClient.auth.signOut(); window.location.href = 'index.html'; });

        addMajorBtn.addEventListener('click', () => {
            const newRule = { name: '新しい学類', userId: currentUser.id, groups: [], combinedLimits: [], totalCap: 24, otherWeight: 1.0, otherCap: 0, allowed_roles: [], thresholds: { applicable: { pass: 80, median: 90 }, non_applicable: { pass: 70, median: 80 } }, maxPossibleScore: 2400 };
            majorRules.push(newRule);
            renderAllRules();
        });

        let draggedItem = null;
        customMajorsContainer.addEventListener('dragstart', (e) => {
             if (e.target.classList.contains('rule-editor')) {
                draggedItem = e.target;
                setTimeout(() => { if (draggedItem) draggedItem.classList.add('dragging'); }, 0);
            }
        });
        customMajorsContainer.addEventListener('dragend', (e) => {
            if(draggedItem) { draggedItem.classList.remove('dragging'); draggedItem = null; }
        });
        customMajorsContainer.addEventListener('dragover', (e) => {
            e.preventDefault();
            if (!draggedItem) return;
            const afterElement = getDragAfterElement(customMajorsContainer, e.clientY);
            if (afterElement == null) { customMajorsContainer.appendChild(draggedItem); } 
            else { customMajorsContainer.insertBefore(draggedItem, afterElement); }
        });
        customMajorsContainer.addEventListener('drop', (e) => {
            e.preventDefault();
            if (!draggedItem) return;
            draggedItem.classList.remove('dragging');
            saveOrderBtn.style.display = 'block';
        });
        function getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.rule-editor:not(.dragging)')];
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                if (offset < 0 && offset > closest.offset) { return { offset: offset, element: child }; } 
                else { return closest; }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }

        saveOrderBtn.addEventListener('click', async () => {
            const newElements = Array.from(customMajorsContainer.querySelectorAll('.rule-editor'));
            const updates = [];
            
            newElements.forEach((element, index) => {
                const ruleId = element.dataset.majorId;
                if (ruleId && !ruleId.startsWith('new-')) {
                    const ruleData = readRuleFromDOM(element); // UIから全データを読み取る
                    updates.push({
                        id: ruleId,
                        name: ruleData.name, // nameを含める
                        allowed_roles: ruleData.allowed_roles, // allowed_rolesを含める
                        rule_data: ruleData.rule_data, // rule_dataを含める
                        sort_order: index // sort_orderを更新
                    });
                }
            });

            if (updates.length > 0) {
                const { error } = await supabaseClient.from('major_rules').upsert(updates);
                if (error) {
                    alert('並び順の保存に失敗しました: ' + error.message);
                } else {
                    alert('並び順を保存しました。');
                    saveOrderBtn.style.display = 'none';
                    await loadMajorRules(); 
                }
            } else {
                alert('並び順を保存する対象の、保存済みルールがありません。');
                saveOrderBtn.style.display = 'none';
            }
        });

        customMajorsContainer.addEventListener('click', async (e) => {
            const target = e.target;
            const ruleEditor = target.closest('.rule-editor');
            if (!ruleEditor) return;
            if(ruleEditor.querySelector('summary').contains(target) && (target.tagName === 'BUTTON' || target.tagName === 'SELECT')) { e.preventDefault(); }
            
            if (target.matches('.duplicate-major-btn')) {
                const ruleToDuplicate = readRuleFromDOM(ruleEditor);
                delete ruleToDuplicate.id; 
                ruleToDuplicate.name = `${ruleToDuplicate.name} (コピー)`;
                majorRules.push(ruleToDuplicate);
                renderAllRules();
            } else if (target.matches('.add-combined-limit-btn')) {
                const container = ruleEditor.querySelector('.combined-limits-container');
                const groups = Array.from(ruleEditor.querySelectorAll('.group-box:not(.combined-limit-box) .group-name')).map(input => ({name: input.value.trim()})).filter(g => g.name);
                container.insertAdjacentHTML('beforeend', createCombinedLimitHTML({}, groups));
            } else if (target.matches('.remove-combined-limit-btn')) {
                target.closest('.combined-limit-box').remove();
            } else if (target.matches('.remove-major-btn')) {
                const ruleId = ruleEditor.dataset.majorId;
                if (ruleId.startsWith('new-')) {
                    const indexToRemove = parseInt(ruleId.replace('new-', ''));
                    majorRules.splice(indexToRemove, 1);
                    renderAllRules();
                    return;
                }
                const ruleName = ruleEditor.querySelector('.major-name').value;
                if (confirm(`「${ruleName}」を完全に削除しますか？`)) {
                    const { error } = await supabaseClient.from('major_rules').delete().eq('id', ruleId);
                    if (error) alert('削除に失敗: ' + error.message);
                    else { alert('削除しました。'); await loadMajorRules(); }
                }
            } else if (target.matches('.add-group-btn')) {
                const groupsContainer = ruleEditor.querySelector('.groups-container');
                groupsContainer.insertAdjacentHTML('beforeend', createGroupHTML({}));
            } else if (target.matches('.remove-group-btn')) {
                target.closest('.group-box').remove();
            } else if (target.matches('.remove-subject-tag')) {
                target.parentElement.remove();
            } else if (target.matches('.add-subject-to-group-btn')) {
                const input = target.previousElementSibling;
                const subjectName = input.value.trim();
                if (subjectName) {
                    const subjectsContainer = input.closest('.group-box').querySelector('.subjects-container');
                    const existingSubjects = Array.from(subjectsContainer.querySelectorAll('.subject-tag')).map(t => t.textContent.slice(0, -1));
                    if (!existingSubjects.includes(subjectName)) {
                        subjectsContainer.insertAdjacentHTML('beforeend', `<div class="subject-tag">${subjectName}<span class="remove-subject-tag">&times;</span></div>`);
                    }
                    input.value = '';
                }
            } else if (target.matches('.save-one-rule-btn')) {
                const ruleId = ruleEditor.dataset.majorId.startsWith('new-') ? null : ruleEditor.dataset.majorId;
                const ruleData = readRuleFromDOM(ruleEditor);
                if (!ruleData.name) { alert('学類名は必須です。'); return; }
                let query;
                if (ruleId) {
                    query = supabaseClient.from('major_rules').update({ name: ruleData.name, allowed_roles: ruleData.allowed_roles, rule_data: ruleData.rule_data }).eq('id', ruleId);
                } else {
                    query = supabaseClient.from('major_rules').insert({ user_id: currentUser.id, name: ruleData.name, allowed_roles: ruleData.allowed_roles, rule_data: ruleData.rule_data });
                }
                const { error } = await query;
                if (error) { alert('保存に失敗: ' + error.message); }
                else { alert(`「${ruleData.name}」を保存しました。`); await loadMajorRules(); }
            }
        });
        
        function readRuleFromDOM(ruleEditor) {
            return {
                id: ruleEditor.dataset.majorId.startsWith('new-') ? null : ruleEditor.dataset.majorId,
                name: ruleEditor.querySelector('.major-name').value.trim(),
                allowed_roles: Array.from(ruleEditor.querySelectorAll('.role-checkbox:checked')).map(cb => cb.value),
                rule_data: {
                    totalCap: parseFloat(ruleEditor.querySelector('.total-cap').value) || 0,
                    otherWeight: parseFloat(ruleEditor.querySelector('.other-weight').value) || 0,
                    otherCap: parseFloat(ruleEditor.querySelector('.other-cap').value) || 0,
                    thresholds: {
                        applicable: { pass: parseFloat(ruleEditor.querySelector('.pass-threshold-app').value) || 0, median: parseFloat(ruleEditor.querySelector('.median-threshold-app').value) || 0 },
                        non_applicable: { pass: parseFloat(ruleEditor.querySelector('.pass-threshold-nonapp').value) || 0, median: parseFloat(ruleEditor.querySelector('.median-threshold-nonapp').value) || 0 }
                    },
                    maxPossibleScore: parseFloat(ruleEditor.querySelector('.max-possible-score').value) || 0,
                    groups: Array.from(ruleEditor.querySelectorAll('.group-box:not(.combined-limit-box)')).map(groupEl => ({ name: groupEl.querySelector('.group-name').value.trim(), weight: parseFloat(groupEl.querySelector('.group-weight').value) || 0, cap: parseFloat(groupEl.querySelector('.group-cap').value) || 0, subjects: Array.from(groupEl.querySelectorAll('.subject-tag')).map(tag => tag.textContent.slice(0, -1)) })),
                    combinedLimits: Array.from(ruleEditor.querySelectorAll('.combined-limit-box')).map(limitEl => ({
                        name: limitEl.querySelector('.combined-limit-name').value.trim(),
                        cap: parseFloat(limitEl.querySelector('.combined-limit-cap').value) || 0,
                        groupNames: Array.from(limitEl.querySelectorAll('.combined-group-checkbox:checked')).map(cb => cb.value)
                    }))
                }
            };
        }
    </script>
</body>
</html>
