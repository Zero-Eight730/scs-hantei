<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-client.js"></script>
    <title>判定実行 - 成績計算サイト</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div id="main-app" class="container" style="display:none;">
        <nav>
            <a href="/input.html">成績入力</a>
            <a href="/view.html">成績参照</a>
            <strong>判定実行</strong>
        </nav>
        <div class="user-status">
             <span id="user-display"></span>
             <button id="logout-btn" class="btn-danger" style="padding: 5px 10px; font-size: 14px;">ログアウト</button>
        </div>
        <div class="panel">
            <h2>判定実行</h2>
            <p style="text-align:center;">保存されている最新の成績データを使用して、各学類の移行点を計算します。</p>
            <button id="calculate-btn" class="btn-main" style="width:100%; padding: 15px; font-size: 18px;">計算を実行</button>
            <div id="results-container"></div>
        </div>
    </div>
    <script>
        const userDisplay = document.getElementById('user-display');
        const logoutBtn = document.getElementById('logout-btn');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultsContainer = document.getElementById('results-container');
        let savedSubjects = [];

        const RULES = {
            '情報科学類（区分A）': {
                groups: [
                    { name: 'グループA', subjects: ['知能と情報科学', '計算と情報科学', 'システムと情報科学', '情報科学概論', '情報メディア入門', 'コンテンツ入門', '知識情報概論', '知識情報システム概説', '図書館概論'], weight: 1.0, cap: 2 },
                    { name: 'グループB', subjects: ['情報数学A', 'プログラミング入門A'], weight: 1.0, cap: 4 },
                    { name: 'グループC', subjects: ['微分積分A', '微分積分1', '微分積分2'], weight: 1.0, cap: 2 },
                    { name: 'グループD', subjects: ['線形代数A', '線形代数1', '線形代数2'], weight: 1.0, cap: 2 }
                ],
                otherWeight: 0.1, totalCap: 20, passThreshold: 83.3, medianThreshold: 87.2
            },
            '情報科学類（区分B）': { otherWeight: 1.0, totalCap: 24, passThreshold: 87.5, medianThreshold: 89.9 },
            '情報メディア創成学類': { otherWeight: 1.0, totalCap: 24, passThreshold: 90.6, medianThreshold: 92.4 },
            '知識情報・図書館学類': { otherWeight: 1.0, totalCap: 24, passThreshold: 83.3, medianThreshold: 87.2 },
            '物理学類': {
                prioritySubjects: ['力学1', '力学2', '力学3', '電磁気1', '電磁気2', '電磁気3', '物理学入門', '数学リテラシー1', '数学リテラシー2', '微分積分3', '線形代数3', '線形代数1', '線形代数2', '線形代数A', '微分積分A', '微分積分1', '微分積分2'],
                priorityWeight: 2.0,
                subCaps: [
                    { name: '微分積分枠', subjects: ['微分積分1', '微分積分2', '微分積分A'], cap: 2 },
                    { name: '線形代数枠', subjects: ['線形代数1', '線形代数2', '線形代数A'], cap: 2 }
                ],
                otherWeight: 1.0, priorityCreditCap: 18, totalCap: 24, passThreshold: 91.9, medianThreshold: 94.6
            }
        };

        async function checkSession() {
            try {
                const res = await fetch('/api/session');
                const data = await res.json();
                if (data.loggedIn) {
                    document.getElementById('main-app').style.display = 'block';
                    userDisplay.textContent = `${data.username} としてログイン中`;
                    loadInitialData();
                } else { window.location.href = '/login.html'; }
            } catch (error) { window.location.href = '/login.html'; }
        }
        
        async function loadInitialData() {
            try {
                const res = await fetch('/api/load');
                if (!res.ok) throw new Error('保存済みデータがありません。入力ページで成績を保存してください。');
                const data = await res.json();
                savedSubjects = (data.subjects || []).map(s => ({
                    name: s.name, credits: parseFloat(s.credits), grade: parseFloat(s.grade)
                })).filter(s => s.name && !isNaN(s.credits) && !isNaN(s.grade));
            } catch (e) {
                resultsContainer.innerHTML = `<p style="text-align:center; color: var(--danger-color);">${e.message}</p>`;
                calculateBtn.disabled = true;
            }
        }

        document.addEventListener('DOMContentLoaded', checkSession);
        logoutBtn.addEventListener('click', async () => {
            await fetch('/api/logout', { method: 'POST' });
            window.location.href = '/login.html';
        });

        calculateBtn.addEventListener('click', () => {
            if (savedSubjects.length === 0) { alert('計算対象の科目がありません。入力ページで成績を保存してください。'); return; }
            resultsContainer.innerHTML = '';
            const majorsToCalculate = ['情報科学類（区分A）', '情報科学類（区分B）', '情報メディア創成学類', '知識情報・図書館学類', '物理学類'];
            majorsToCalculate.forEach(majorName => {
                const rule = RULES[majorName];
                let result;
                if (majorName === '情報科学類（区分A）') result = calculateInfoSciA(savedSubjects, rule);
                else if (majorName === '物理学類') result = calculatePhysics(savedSubjects, rule);
                else result = calculateSimpleMajor(savedSubjects, rule);
                const percentage = result.maxScore > 0 ? (result.score / result.maxScore) * 100 : 0;
                const p_plus_thresh = rule.medianThreshold; const p_thresh = rule.passThreshold; const b_thresh = (p_plus_thresh + p_thresh) / 2; const d_thresh = p_thresh - (b_thresh - p_thresh);
                let judgment, judgmentClass;
                if (percentage >= p_plus_thresh) { judgment = 'A'; judgmentClass = 'judgment-A'; } 
                else if (percentage >= b_thresh) { judgment = 'B'; judgmentClass = 'judgment-B'; } 
                else if (percentage >= p_thresh) { judgment = 'C'; judgmentClass = 'judgment-C'; } 
                else if (percentage >= d_thresh) { judgment = 'D'; judgmentClass = 'judgment-D'; } 
                else { judgment = 'E'; judgmentClass = 'judgment-E'; }
                renderResultCard(majorName, result, judgment, judgmentClass, percentage);
            });
        });

        function normalizeName(name) {
            if (typeof name !== 'string') return '';
            return name.replace(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/\s+/g, '');
        }

        function calculateInfoSciA(subjects, rule) {
            let remainingSubjects = JSON.parse(JSON.stringify(subjects));
            let breakdown = []; let totalScore = 0; let totalCredits = 0; let maxScore = 0;
            const includedNames = new Set();
            rule.groups.forEach(group => {
                let groupSubjects = remainingSubjects.filter(s => group.subjects.includes(normalizeName(s.name)));
                groupSubjects.sort((a, b) => b.grade - a.grade);
                let groupCredits = 0;
                groupSubjects.forEach(subject => {
                    if (groupCredits + subject.credits <= group.cap) {
                        groupCredits += subject.credits;
                        totalScore += subject.grade * subject.credits * group.weight;
                        maxScore += 100 * subject.credits * group.weight;
                        breakdown.push({ text: `${subject.name} (${group.name})`, status: 'included'});
                        includedNames.add(subject.name);
                    }
                });
                totalCredits += groupCredits;
            });
            remainingSubjects = subjects.filter(s => !includedNames.has(s.name));
            remainingSubjects.forEach(s => s.efficiency = s.grade * rule.otherWeight);
            remainingSubjects.sort((a, b) => b.efficiency - a.efficiency);
            for (const subject of remainingSubjects) {
                if (totalCredits + subject.credits <= rule.totalCap) {
                    totalCredits += subject.credits;
                    totalScore += subject.grade * subject.credits * rule.otherWeight;
                    maxScore += 100 * subject.credits * rule.otherWeight;
                    breakdown.push({ text: `${subject.name} (その他)`, status: 'included' });
                }
            }
            return { score: totalScore, credits: totalCredits, breakdown, maxScore };
        }

        function calculateSimpleMajor(subjects, rule) {
            const allSubjects = JSON.parse(JSON.stringify(subjects));
            allSubjects.forEach(s => s.efficiency = s.grade * rule.otherWeight);
            allSubjects.sort((a, b) => b.efficiency - a.efficiency);
            let totalScore = 0; let totalCredits = 0; let breakdown = []; let maxScore = 0;
            for (const subject of allSubjects) {
                if (totalCredits + subject.credits <= rule.totalCap) {
                    totalCredits += subject.credits;
                    totalScore += subject.grade * subject.credits * rule.otherWeight;
                    maxScore += 100 * subject.credits * rule.otherWeight;
                    breakdown.push({ text: subject.name, status: 'included' });
                }
            }
            return { score: totalScore, credits: totalCredits, breakdown, maxScore };
        }

        function calculatePhysics(subjects, rule) {
            const allSubjects = JSON.parse(JSON.stringify(subjects));
            let breakdown = [];
            allSubjects.forEach(s => {
                const normalizedName = normalizeName(s.name);
                let weight = rule.prioritySubjects.includes(normalizedName) ? rule.priorityWeight : rule.otherWeight;
                s.weight = weight;
                s.efficiency = s.grade * s.weight;
            });
            allSubjects.sort((a, b) => b.efficiency - a.efficiency);
            let totalScore = 0; let totalCredits = 0; let maxScore = 0;
            let subCapCredits = { '微分積分枠': 0, '線形代数枠': 0 };
            const includedNames = new Set();
            const unprocessedSubjects = [];
            for (const subject of allSubjects) {
                const normalizedName = normalizeName(subject.name);
                if (totalCredits >= rule.totalCap) {
                     unprocessedSubjects.push({ subject, reason: '総単位数上限(24)超過' });
                     continue;
                }
                let scoreMultiplier = 1.0;
                let note = `(x${subject.weight} @ 1.0倍)`;
                let subCapOverflow = false;
                for (const subCap of rule.subCaps) {
                    if (subCap.subjects.includes(normalizedName)) {
                        if (subCapCredits[subCap.name] + subject.credits > subCap.cap) {
                            scoreMultiplier = 0.1;
                            note = `(x${subject.weight} @ 0.1倍 [枠超過])`;
                            subCapOverflow = true;
                        }
                    }
                }
                if (!subCapOverflow && totalCredits >= rule.priorityCreditCap) {
                    scoreMultiplier = 0.1;
                    note = `(x${subject.weight} @ 0.1倍)`;
                }
                if (totalCredits + subject.credits > rule.totalCap) {
                     unprocessedSubjects.push({ subject, reason: '総単位数上限(24)超過' });
                     continue;
                }
                const scoreToAdd = subject.grade * subject.credits * subject.weight * scoreMultiplier;
                const maxScoreToAdd = 100 * subject.credits * subject.weight * scoreMultiplier;
                totalCredits += subject.credits;
                totalScore += scoreToAdd;
                maxScore += maxScoreToAdd;
                breakdown.push({ text: `${subject.name} [貢献:${scoreToAdd.toFixed(2)}] ${note}`, status: 'included' });
                includedNames.add(subject.name);
                if (!subCapOverflow) {
                    for (const subCap of rule.subCaps) {
                        if (subCap.subjects.includes(normalizedName)) {
                            subCapCredits[subCap.name] += subject.credits;
                        }
                    }
                }
            }
            allSubjects.forEach(s => {
                if (!includedNames.has(s.name)) {
                     const unprocessed = unprocessedSubjects.find(u => u.subject.name === s.name);
                     const reason = unprocessed ? unprocessed.reason : '優先度不足';
                     breakdown.push({ text: s.name, status: 'excluded', reason: reason });
                }
            });
            return { score: totalScore, credits: totalCredits, breakdown, maxScore };
        }

        async function renderResultCard(majorName, result, judgment, judgmentClass, percentage) {
            const card = document.createElement('div');
            card.className = `result-card`;
            card.style.borderColor = judgment === 'E' ? '#6c757d' : judgment === 'C' || judgment === 'D' ? '#28a745' : judgment === 'B' ? '#ee9b00' : '#e63946';
            const safeMajorName = majorName.replace(/[\s()（）]/g, '');
            let breakdownHTML = result.breakdown.length > 0 ? '<ul>' + result.breakdown.map(item => {
                const className = item.status === 'included' ? 'status-included' : 'status-excluded';
                const text = item.status === 'included' ? item.text : `${item.text} - ${item.reason}`;
                return `<li class="${className}">${text}</li>`;
            }).join('') + '</ul>' : '<p>計算対象なし</p>';
            card.innerHTML = `
                <h4>${majorName}</h4>
                <div class="judgment ${judgmentClass}">${judgment}</div>
                <div class="score-details"><span class="score">${result.score.toFixed(2)}</span> / <span class="percentage">(${percentage.toFixed(2)}%)</span></div>
                <div class="credits-info">合計 ${result.credits.toFixed(1)} / ${RULES[majorName].totalCap} 単位</div>
                <div class="rank-info" id="rank-${safeMajorName}"><p style="font-size:0.9em; color:#666;">順位を読み込み中...</p></div>
                <details><summary>計算内訳</summary>${breakdownHTML}</details>
            `;
            resultsContainer.appendChild(card);
            try {
                const res = await fetch(`/api/rank/${encodeURIComponent(majorName)}`);
                const rankData = await res.json();
                if (!res.ok) throw new Error(rankData.message);
                const rankInfoDiv = document.getElementById(`rank-${safeMajorName}`);
                rankInfoDiv.innerHTML = `
                    <span class="rank-value">${rankData.rank}</span><span style="font-size: 1.2em;"> 位</span>
                    <span style="font-size: 0.9em; color: #666;"> / ${rankData.total}人中</span><br>
                    <span class="deviation-value">偏差値: ${rankData.deviationScore.toFixed(2)}</span>
                `;
            } catch (error) {
                const rankInfoDiv = document.getElementById(`rank-${safeMajorName}`);
                rankInfoDiv.innerHTML = `<p style="font-size: 0.9em; color: #999;">${error.message}</p>`;
            }
        }
    </script>
</body>
</html>
