<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>判定実行 - 成績計算サイト</title>
    <link rel="stylesheet" href="style.css">
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <script src="supabase-client.js"></script>
</head>
<body>
    <div id="main-app" class="container" style="display:none;">
        <nav>
            <a href="input.html">成績入力</a>
            <a href="view.html">成績参照</a>
            <strong>判定実行</strong>
            <a href="rules.html">ルール設定</a>
            <a href="account.html">アカウント管理</a>
        </nav>
        <div class="user-status">
             <span id="user-display"></span>
             <button id="logout-btn" class="btn-danger" style="padding: 5px 10px; font-size: 14px;">ログアウト</button>
        </div>
        <div class="panel">
            <h2>判定実行</h2>
            <p style="text-align:center;">「志望学類登録」で選択した学類の移行点を計算します。</p>
            <button id="calculate-btn" class="btn-main" style="width:100%; padding: 15px; font-size: 18px;">計算を実行</button>
            <div id="results-container"></div>
        </div>
    </div>
    <script>
        let currentUser = null;
        let savedSubjects = [];
        let allPublicRules = [];
        let targetMajors = [];
        const userDisplay = document.getElementById('user-display');
        const logoutBtn = document.getElementById('logout-btn');
        const calculateBtn = document.getElementById('calculate-btn');
        const resultsContainer = document.getElementById('results-container');
        
        async function checkSessionAndInitialize() {
            const { data: { session }, error } = await supabaseClient.auth.getSession();
            if (error || !session) { window.location.href = 'index.html'; return; }
            currentUser = session.user;
            document.getElementById('main-app').style.display = 'block';
            userDisplay.textContent = `${currentUser.email} でログイン中`;
            await loadInitialData();
        }
        
        async function loadInitialData() {
            try {
                const { data: userData, error: userError } = await supabaseClient.from('user_data').select('subjects, target_majors').eq('id', currentUser.id).single();
                if (userError && userError.code !== 'PGRST116') throw userError;
                savedSubjects = (userData?.subjects || []).map(s => ({ name: s.name, credits: parseFloat(s.credits), grade: parseFloat(s.grade) })).filter(s => s.name && !isNaN(s.credits) && !isNaN(s.grade));
                targetMajors = userData?.target_majors || [];

                const { data: rulesData, error: rulesError } = await supabaseClient.from('major_rules').select('name, rule_data');
                if (rulesError) throw rulesError;
                allPublicRules = rulesData.map(r => ({ ...r.rule_data, name: r.name }));

            } catch (e) {
                resultsContainer.innerHTML = `<p style="text-align:center; color: var(--danger-color);">${e.message || 'データの読み込みに失敗しました。'}</p>`;
                calculateBtn.disabled = true;
            }
        }

        document.addEventListener('DOMContentLoaded', checkSessionAndInitialize);
        logoutBtn.addEventListener('click', async () => { await supabaseClient.auth.signOut(); window.location.href = 'index.html'; });

        calculateBtn.addEventListener('click', async () => {
            if (savedSubjects.length === 0) { alert('計算対象の科目がありません。「成績入力」ページでデータを保存してください。'); return; }
            if (targetMajors.length === 0) { alert('計算対象の学類がありません。「志望学類登録」ページで設定してください。'); return; }
            
            resultsContainer.innerHTML = '<p style="text-align:center;">スコアを計算・更新中...</p>';
            
            // スコアを更新するために保存APIを叩く
            const { data: existingData } = await supabaseClient.from('user_data').select('custom_rules, target_majors').eq('id', currentUser.id).single();
            const { error: saveError } = await supabaseClient.from('user_data').upsert({ id: currentUser.id, subjects: savedSubjects, custom_rules: existingData?.custom_rules, target_majors: existingData?.target_majors, updated_at: new Date() });

            if(saveError){ alert("スコアの更新に失敗しました: " + saveError.message); return; }

            resultsContainer.innerHTML = '';
            
            const rulesToCalculate = allPublicRules.filter(rule => targetMajors.includes(rule.name));
            
            rulesToCalculate.forEach(rule => {
                const result = calculateCustomMajor(savedSubjects, rule);
                renderResultCard(rule.name, result, rule);
            });
        });

        function normalizeName(name) { if (typeof name !== 'string') return ''; return name.replace(/[０-９]/g, (s) => String.fromCharCode(s.charCodeAt(0) - 0xFEE0)).replace(/\s+/g, ''); }

        function calculateCustomMajor(subjects, rule) {
            let remainingSubjects = JSON.parse(JSON.stringify(subjects));
            let breakdown = []; let totalScore = 0; let totalCredits = 0; let maxScore = 0;
            const includedNames = new Set();
            (rule.groups || []).forEach(group => {
                let groupSubjects = remainingSubjects.filter(s => (group.subjects || []).includes(s.name));
                groupSubjects.sort((a, b) => b.grade - a.grade);
                let groupCredits = 0;
                groupSubjects.forEach(subject => {
                    if (groupCredits + subject.credits <= group.cap) {
                        groupCredits += subject.credits;
                        totalScore += subject.grade * subject.credits * group.weight;
                        maxScore += 100 * subject.credits * group.weight;
                        breakdown.push({ text: `${subject.name} (${group.name})`, status: 'included'});
                        includedNames.add(subject.name);
                    }
                });
                totalCredits += groupCredits;
            });
            remainingSubjects = subjects.filter(s => !includedNames.has(s.name));
            remainingSubjects.forEach(s => s.efficiency = s.grade * rule.otherWeight);
            remainingSubjects.sort((a, b) => b.efficiency - a.efficiency);
            for (const subject of remainingSubjects) {
                if (totalCredits + subject.credits <= rule.totalCap) {
                    totalCredits += subject.credits;
                    totalScore += subject.grade * subject.credits * rule.otherWeight;
                    maxScore += 100 * subject.credits * rule.otherWeight;
                    breakdown.push({ text: `${subject.name} (その他)`, status: 'included' });
                }
            }
            return { score: totalScore, credits: totalCredits, breakdown, maxScore };
        }
        
        async function renderResultCard(majorName, result, rule) {
            const percentage = result.maxScore > 0 ? (result.score / result.maxScore) * 100 : 0;
            let judgment = 'N/A', judgmentClass = 'judgment-E';
            if (rule.passThreshold && rule.medianThreshold) {
                const p_plus_thresh = rule.medianThreshold; const p_thresh = rule.passThreshold;
                const b_thresh = (p_plus_thresh + p_thresh) / 2; const d_thresh = p_thresh - (b_thresh - p_thresh);
                if (percentage >= p_plus_thresh) { judgment = 'A'; judgmentClass = 'judgment-A'; } 
                else if (percentage >= b_thresh) { judgment = 'B'; judgmentClass = 'judgment-B'; } 
                else if (percentage >= p_thresh) { judgment = 'C'; judgmentClass = 'judgment-C'; } 
                else if (percentage >= d_thresh) { judgment = 'D'; judgmentClass = 'judgment-D'; } 
                else { judgment = 'E'; judgmentClass = 'judgment-E'; }
            }
            
            const card = document.createElement('div');
            card.className = `result-card`;
            card.style.borderTopColor = `var(--grade-${judgment}-color)`;
            const safeMajorName = majorName.replace(/[\s()（）]/g, '');
            let breakdownHTML = result.breakdown.length > 0 ? '<ul>' + result.breakdown.map(item => `<li class="status-included">${item.text}</li>`).join('') + '</ul>' : '<p>計算対象なし</p>';
            card.innerHTML = `
                <div class="card-header"><h4>${majorName}</h4></div>
                <div class="judgment-display"><div class="judgment-circle grade-${judgment}"><span>${judgment}</span></div></div>
                <div class="details-display">
                    <div class="detail-item"><span class="label">移行点</span><span class="value">${result.score.toFixed(2)}</span></div>
                    <div class="detail-item"><span class="label">得点率</span><span class="value">${percentage.toFixed(2)} %</span></div>
                    <div class="rank-info" id="rank-${safeMajorName}"><p>順位を読み込み中...</p></div>
                </div>
                <div class="breakdown-display"><details><summary>計算内訳</summary>${breakdownHTML}</details></div>
            `;
            resultsContainer.appendChild(card);
            try {
                const { data, error } = await supabaseClient.rpc('get_rank_and_deviation', { major_name: majorName });
                if (error) throw new Error(error.message);
                if (!data || data.length === 0) throw new Error('スコア未登録か、比較対象がいません');
                const rankData = data[0];
                document.getElementById(`rank-${safeMajorName}`).innerHTML = `
                    <div class="detail-item"><span class="label">偏差値</span><span class="value">${rankData.deviation_score.toFixed(2)}</span></div>
                    <div class="detail-item" style="border-bottom: none;"><span class="label">順位</span><span class="value">${rankData.rank} / ${rankData.total}人</span></div>
                `;
            } catch (error) {
                document.getElementById(`rank-${safeMajorName}`).innerHTML = `<p style="font-size: 0.9em; color: var(--text-muted);">${error.message}</p>`;
            }
        }
    </script>
</body>
</html>
